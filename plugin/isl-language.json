{
  "modifierValidationPatterns": [
    "to.*",
    "hex.*",
    "join.*",
    "email.*",
    "encode.*",
    "decode.*",
    "json.*",
    "yaml.*",
    "xml.*",
    "csv.*",
    "regex.*",
    "date.*",
    "round.*",
    "html.*",
    "Crypto.*",
    "zip.*",
    "retry.*",
    "Math.*"
  ],
  "modifiers": [
    {"name": "to.string", "detail": "Convert to string", "insertText": "to.string", "returns": {"type": "String"}, "documentation": "Converts value to string.\n\nFor dates: `to.string(format)`", "signature": {"label": "to.string(format?: string)", "parameters": [{"label": "format", "documentation": "For dates: format pattern (e.g., \"yyyy-MM-dd HH:mm:ss\")"}], "documentation": "Converts value to string. For dates, optional format parameter."}, "hover": {"description": "Converts value to string. Also used for date formatting.", "signature": "to.string or to.string(format) for dates", "example": "$id: $num | to.string;\n$date: $timestamp | to.string(\"yyyy-MM-dd\");"}},
    {"name": "to.number", "detail": "Convert to number", "insertText": "to.number", "returns": {"type": "Number"}, "hover": {"description": "Converts value to integer number.", "signature": "to.number", "example": "$count: $input.count | to.number;"}},
    {"name": "to.decimal", "detail": "Convert to decimal", "insertText": "to.decimal", "returns": {"type": "Number"}, "hover": {"description": "Converts value to decimal number.", "signature": "to.decimal", "example": "$price: $input.price | to.decimal;"}},
    {"name": "to.boolean", "detail": "Convert to boolean", "insertText": "to.boolean", "returns": {"type": "Boolean"}, "hover": {"description": "Converts value to boolean.", "signature": "to.boolean", "example": "$active: $input.active | to.boolean;"}},
    {"name": "to.array", "detail": "Convert to array", "insertText": "to.array", "returns": {"type": "Array"}, "hover": {"description": "Converts value to array.", "signature": "to.array", "example": "$items: $single | to.array;"}},
    {"name": "to.object", "detail": "Convert to object", "insertText": "to.object", "returns": {"type": "Object"}},
    {"name": "to.json", "detail": "Convert to JSON string", "insertText": "to.json", "returns": {"type": "String"}, "hover": {"description": "Converts object to JSON string.", "signature": "to.json", "example": "$jsonStr: $object | to.json;"}},
    {"name": "to.yaml", "detail": "Convert to YAML string", "insertText": "to.yaml"},
    {"name": "to.csv", "detail": "Convert to CSV string", "insertText": "to.csv"},
    {"name": "to.xml", "detail": "Convert to XML", "insertText": "to.xml(\"${1:root}\")", "signature": {"label": "to.xml(rootName: string)", "parameters": [{"label": "rootName", "documentation": "Root element name for XML"}], "documentation": "Converts object to XML string"}, "hover": {"description": "Converts object to XML string.", "signature": "to.xml(rootName)", "example": "$xml: $object | to.xml(\"root\");"}},
    {"name": "to.hex", "detail": "Convert to hex string", "insertText": "to.hex"},
    {"name": "to.bytes", "detail": "Convert to byte array", "insertText": "to.bytes(\"${1:UTF-8}\")", "signature": {"label": "to.bytes(charset?: string)", "parameters": [{"label": "charset", "documentation": "Character set (default UTF-8)"}], "documentation": "Converts string to byte array"}, "hover": {"description": "Converts value to byte array.", "signature": "to.bytes(charset?)", "example": "$bytes: $str | to.bytes;"}},
    {"name": "to.epochmillis", "detail": "Convert date to epoch milliseconds", "insertText": "to.epochmillis", "hover": {"description": "Converts date to epoch milliseconds.", "signature": "to.epochmillis", "example": "$timestamp: $date | to.epochmillis;"}},
    {"name": "trim", "detail": "Trim whitespace", "insertText": "trim", "returns": {"type": "String"}, "hover": {"description": "Removes leading and trailing whitespace from a string.", "signature": "trim", "example": "$name: $input.name | trim;"}},
    {"name": "trimStart", "detail": "Trim start whitespace", "insertText": "trimStart"},
    {"name": "trimEnd", "detail": "Trim end whitespace", "insertText": "trimEnd"},
    {"name": "upperCase", "detail": "Convert to uppercase", "insertText": "upperCase", "hover": {"description": "Converts a string to uppercase.", "signature": "upperCase", "example": "$code: $input.status | upperCase;"}},
    {"name": "lowerCase", "detail": "Convert to lowercase", "insertText": "lowerCase", "hover": {"description": "Converts a string to lowercase.", "signature": "lowerCase", "example": "$email: $input.email | lowerCase;"}},
    {"name": "capitalize", "detail": "Capitalize first letter", "insertText": "capitalize", "hover": {"description": "Capitalizes the first letter of a string.", "signature": "capitalize", "example": "$name: \"john\" | capitalize;"}},
    {"name": "titleCase", "detail": "Convert to title case", "insertText": "titleCase", "hover": {"description": "Converts a string to title case (capitalizes each word).", "signature": "titleCase", "example": "$title: \"hello world\" | titleCase;"}},
    {"name": "camelCase", "detail": "Convert to camelCase", "insertText": "camelCase"},
    {"name": "snakeCase", "detail": "Convert to snake_case", "insertText": "snakeCase"},
    {"name": "left", "detail": "Get left N characters", "insertText": "left(${1:length})"},
    {"name": "right", "detail": "Get right N characters", "insertText": "right(${1:length})"},
    {"name": "cap", "detail": "Cap string at length (alias for left)", "insertText": "cap(${1:length})"},
    {"name": "split", "detail": "Split string", "insertText": "split(\"${1:,}\")", "returns": {"type": "Array"}, "signature": {"label": "split(delimiter: string)", "parameters": [{"label": "delimiter", "documentation": "The string to split on (e.g., \",\", \" \")"}], "documentation": "Splits a string into an array using the delimiter"}, "hover": {"description": "Splits a string into an array using a delimiter.", "signature": "split(delimiter)", "example": "$tags: \"red,blue,green\" | split(\",\");"}},
    {"name": "replace", "detail": "Replace string", "insertText": "replace(\"${1:find}\", \"${2:replace}\")", "returns": {"type": "String"}, "signature": {"label": "replace(find: string, replaceWith: string)", "parameters": [{"label": "find", "documentation": "The string to find"}, {"label": "replaceWith", "documentation": "The replacement string"}], "documentation": "Replaces all occurrences of find with replaceWith"}, "hover": {"description": "Replaces occurrences of a substring with another string.", "signature": "replace(find, replaceWith)", "example": "$text: $input | replace(\"old\", \"new\");"}},
    {"name": "remove", "detail": "Remove substring", "insertText": "remove(\"${1:text}\")"},
    {"name": "substring", "detail": "Get substring", "insertText": "substring(${1:start}, ${2:end})", "returns": {"type": "String"}, "signature": {"label": "substring(start: number, end: number)", "parameters": [{"label": "start", "documentation": "Starting index (0-based)"}, {"label": "end", "documentation": "Ending index (exclusive)"}], "documentation": "Extracts a portion of the string"}, "hover": {"description": "Extracts a portion of a string.", "signature": "substring(start, end)", "example": "$code: $input | substring(0, 5);"}},
    {"name": "substringUpto", "detail": "Substring up to delimiter", "insertText": "substringUpto(\"${1:delimiter}\")"},
    {"name": "substringAfter", "detail": "Substring after delimiter", "insertText": "substringAfter(\"${1:delimiter}\")"},
    {"name": "truncate", "detail": "Truncate string", "insertText": "truncate(${1:length}, \"${2:...}\")", "signature": {"label": "truncate(maxLength: number, suffix: string)", "parameters": [{"label": "maxLength", "documentation": "Maximum length of the string"}, {"label": "suffix", "documentation": "Suffix to add if truncated (e.g., \"...\")"}], "documentation": "Truncates string to maxLength and adds suffix if needed"}, "hover": {"description": "Truncates a string to a maximum length with optional suffix.", "signature": "truncate(maxLength, suffix)", "example": "$short: $longText | truncate(100, \"...\");"}},
    {"name": "padStart", "detail": "Pad start", "insertText": "padStart(${1:length}, \"${2: }\")", "signature": {"label": "padStart(length: number, padString: string)", "parameters": [{"label": "length", "documentation": "Target length of the string"}, {"label": "padString", "documentation": "String to pad with (e.g., \"0\", \" \")"}], "documentation": "Pads the start of the string to reach target length"}, "hover": {"description": "Pads the start of a string to a target length.", "signature": "padStart(length, padString)", "example": "$id: $number | to.string | padStart(8, \"0\");"}},
    {"name": "padEnd", "detail": "Pad end", "insertText": "padEnd(${1:length}, \"${2: }\")", "signature": {"label": "padEnd(length: number, padString: string)", "parameters": [{"label": "length", "documentation": "Target length of the string"}, {"label": "padString", "documentation": "String to pad with"}], "documentation": "Pads the end of the string to reach target length"}, "hover": {"description": "Pads the end of a string to a target length.", "signature": "padEnd(length, padString)", "example": "$code: $text | padEnd(10, \" \");"}},
    {"name": "concat", "detail": "Concatenate strings", "insertText": "concat(${1:\\$other}, \"${2:delimiter}\")"},
    {"name": "append", "detail": "Append strings", "insertText": "append(${1:\\$value})"},
    {"name": "reverse", "detail": "Reverse string/array", "insertText": "reverse", "hover": {"description": "Reverses the order of elements in an array.", "signature": "reverse", "example": "$reversed: $array | reverse;"}},
    {"name": "sanitizeTid", "detail": "Sanitize UUID/TID", "insertText": "sanitizeTid"},
    {"name": "filter", "detail": "Filter array", "insertText": "filter(${1:\\$.${2:condition}})", "returns": {"type": "Array"}, "documentation": "Filters array based on condition.\n\nUse $fit or $ for current item being filtered.\n\nExample: `$active: $items | filter($fit.active)`", "signature": {"label": "filter(condition: expression)", "parameters": [{"label": "condition", "documentation": "Boolean expression using $ or $item for current element"}], "documentation": "Filters array elements based on condition. Use $ for current item."}, "hover": {"description": "Filters an array based on a condition. Use $ or $it for current item.", "signature": "filter(condition)", "example": "$active: $items | filter( $.status == \"active\" );"}},
    {"name": "map", "detail": "Map array", "insertText": "map(${1:\\$.${2:property}})", "returns": {"type": "Array"}, "documentation": "Transforms each element.\n\nUse $ for current item.\n\nExample: `$names: $users | map($.name)`", "signature": {"label": "map(expression: any)", "parameters": [{"label": "expression", "documentation": "Transform expression using $ or $item for current element"}], "documentation": "Transforms each array element. Use $ for current item."}, "hover": {"description": "Transforms each element of an array. Use $ or $it for current item.", "signature": "map(expression)", "example": "$names: $users | map($.name);"}},
    {"name": "reduce", "detail": "Reduce array", "insertText": "reduce({{ \\$acc + \\$it }}, ${1:0})", "returns": {"type": "Any"}, "documentation": "Reduces array to single value.\n\nUse $acc (accumulator) and $it (current item).\n\nExample: `$sum: $numbers | reduce({{ $acc + $it }}, 0)`", "signature": {"label": "reduce(expression: any, initialValue: any)", "parameters": [{"label": "expression", "documentation": "Accumulator expression using $acc and $it"}, {"label": "initialValue", "documentation": "Initial value for the accumulator"}], "documentation": "Reduces array to single value. Use $acc (accumulator) and $it (current item)."}, "hover": {"description": "Reduces an array to a single value. Use $acc for accumulator, $it for current item.", "signature": "reduce(expression, initialValue)", "example": "$sum: [1, 2, 3] | reduce({{ $acc + $it }}, 0);"}},
    {"name": "sort", "detail": "Sort array/object", "insertText": "sort", "signature": {"label": "sort(options?: object)", "parameters": [{"label": "options", "documentation": "Optional {by: \"field\", order: \"asc\"|\"desc\", caseSensitive: true|false}"}], "documentation": "Sorts array or object; for arrays use by to sort by field"}, "hover": {"description": "Sorts array or object. Options: by (field), order (asc/desc), caseSensitive.", "signature": "sort(options?)", "example": "$sorted: $numbers | sort;\n$byName: $users | sort({by: \"name\", order: \"asc\"});"}},
    {"name": "unique", "detail": "Get unique values", "insertText": "unique", "signature": {"label": "unique(path?: string)", "parameters": [{"label": "path", "documentation": "Optional JSON path for uniqueness (e.g. $.id)"}], "documentation": "Unique by value or by path"}, "hover": {"description": "Returns unique values from an array. Optional path for uniqueness by field.", "signature": "unique(path?)", "example": "$uniqueTags: $tags | unique;\n$uniqueById: $items | unique($.id);"}},
    {"name": "slice", "detail": "Slice array", "insertText": "slice(${1:start}, ${2:end})"},
    {"name": "length", "detail": "Get length", "insertText": "length", "returns": {"type": "Number"}, "hover": {"description": "Returns the length of a string or array.", "signature": "length", "example": "$count: $array | length;"}},
    {"name": "first", "detail": "Get first element", "insertText": "first", "hover": {"description": "Returns the first element of an array.", "signature": "first", "example": "$firstItem: $array | first;"}},
    {"name": "last", "detail": "Get last element", "insertText": "last", "hover": {"description": "Returns the last element of an array.", "signature": "last", "example": "$lastItem: $array | last;"}},
    {"name": "take", "detail": "Take first N elements", "insertText": "take(${1:n})"},
    {"name": "drop", "detail": "Drop first N elements", "insertText": "drop(${1:n})"},
    {"name": "at", "detail": "Get element at index", "insertText": "at(${1:index})", "documentation": "Supports negative indices: `at(-1)` gets last element", "signature": {"label": "at(index: number)", "parameters": [{"label": "index", "documentation": "Array index (supports negative for counting from end)"}], "documentation": "Returns element at index. Use -1 for last element."}, "hover": {"description": "Returns the element at a specific index (supports negative indices).", "signature": "at(index)", "example": "$second: $array | at(1);\n$lastItem: $array | at(-1);"}},
    {"name": "indexOf", "detail": "Find index of element", "insertText": "indexOf(${1:element})"},
    {"name": "lastIndexOf", "detail": "Find last index of element", "insertText": "lastIndexOf(${1:element})"},
    {"name": "isEmpty", "detail": "Check if empty", "insertText": "isEmpty", "returns": {"type": "Boolean"}, "hover": {"description": "Returns true if array or string is empty.", "signature": "isEmpty", "example": "if ($array | isEmpty) ... endif"}},
    {"name": "isNotEmpty", "detail": "Check if not empty", "insertText": "isNotEmpty", "returns": {"type": "Boolean"}, "hover": {"description": "Returns true if array or string is not empty.", "signature": "isNotEmpty", "example": "if ($array | isNotEmpty) ... endif"}},
    {"name": "push", "detail": "Add item to array", "insertText": "push(${1:item})", "returns": {"type": "Array"}, "signature": {"label": "push(item: any)", "parameters": [{"label": "item", "documentation": "Item to add to array"}], "documentation": "Adds item to end of array"}, "hover": {"description": "Adds an item to the end of an array.", "signature": "push(item)", "example": "$newArray: $array | push($newItem);"}},
    {"name": "pushItems", "detail": "Push full array to end", "insertText": "pushItems(${1:\\$otherArray})", "documentation": "Appends all items from the provided array to the end of the input array.\n\nExample: `$items | pushItems($moreItems)`"},
    {"name": "pop", "detail": "Remove last item", "insertText": "pop", "hover": {"description": "Removes and returns the last element from an array.", "signature": "pop", "example": "$item: $array | pop;"}},
    {"name": "chunk", "detail": "Split into chunks", "insertText": "chunk(${1:size})"},
    {"name": "date.parse", "detail": "Parse date", "insertText": "date.parse(\"${1:yyyy-MM-dd}\")", "returns": {"type": "Date"}, "documentation": "Parses date string.\n\nOptional locale: `date.parse(format, {locale: \"en_US\"})`", "signature": {"label": "date.parse(format: string, options?: object)", "parameters": [{"label": "format", "documentation": "Date format pattern (e.g., \"yyyy-MM-dd\")"}, {"label": "options", "documentation": "Optional: {locale: \"en_US\"}"}], "documentation": "Parses date string using Java DateTimeFormatter patterns"}, "hover": {"description": "Parses a date string with the given format.", "signature": "date.parse(format, {locale})", "example": "$date: \"2024-01-15\" | date.parse(\"yyyy-MM-dd\");"}},
    {"name": "date.add", "detail": "Add to date", "insertText": "date.add(${1:value}, \"${2:DAYS}\")", "returns": {"type": "Date"}, "documentation": "Units: YEARS, MONTHS, DAYS, HOURS, MINUTES, SECONDS", "signature": {"label": "date.add(amount: number, unit: string)", "parameters": [{"label": "amount", "documentation": "Amount to add (can be negative)"}, {"label": "unit", "documentation": "Time unit: YEARS, MONTHS, DAYS, HOURS, MINUTES, SECONDS"}], "documentation": "Adds time to a date"}, "hover": {"description": "Adds time to a date. Units: YEARS, MONTHS, DAYS, HOURS, MINUTES, SECONDS.", "signature": "date.add(amount, unit)", "example": "$tomorrow: $date | date.add(1, \"DAYS\");"}},
    {"name": "date.part", "detail": "Get date part", "insertText": "date.part(\"${1:YEAR}\")", "returns": {"type": "Number"}, "documentation": "Parts: YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, DAYOFYEAR, DAYOFWEEK", "signature": {"label": "date.part(part: string)", "parameters": [{"label": "part", "documentation": "Date part: YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, DAYOFYEAR, DAYOFWEEK"}], "documentation": "Extracts a specific part from a date"}, "hover": {"description": "Extracts a part of a date. Parts: YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, DAYOFYEAR, DAYOFWEEK.", "signature": "date.part(part)", "example": "$year: $date | date.part(\"YEAR\");"}},
    {"name": "date.fromEpochSeconds", "detail": "From epoch seconds", "insertText": "date.fromEpochSeconds"},
    {"name": "date.fromEpochMillis", "detail": "From epoch milliseconds", "insertText": "date.fromEpochMillis"},
    {"name": "date.totimezone", "detail": "Convert date to timezone", "insertText": "date.totimezone(\"${1:UTC}\")", "signature": {"label": "date.totimezone(timeZone: string)", "parameters": [{"label": "timeZone", "documentation": "Timezone ID (e.g. UTC, America/New_York)"}], "documentation": "Converts date to given timezone"}, "hover": {"description": "Converts date to the specified timezone.", "signature": "date.totimezone(timeZone)", "example": "$utc: $date | date.totimezone(\"UTC\");"}},
    {"name": "date.toutc", "detail": "Convert date to UTC", "insertText": "date.toutc"},
    {"name": "date.tolocal", "detail": "Convert date to local timezone", "insertText": "date.tolocal"},
    {"name": "json.parse", "detail": "Parse JSON", "insertText": "json.parse"},
    {"name": "yaml.parse", "detail": "Parse YAML", "insertText": "yaml.parse"},
    {"name": "xml.parse", "detail": "Parse XML", "insertText": "xml.parse"},
    {"name": "csv.parsemultiline", "detail": "Parse CSV", "insertText": "csv.parsemultiline", "documentation": "Options: {headers: true, separator: \",\", skipLines: 0}", "signature": {"label": "csv.parsemultiline(options?: object)", "parameters": [{"label": "options", "documentation": "Optional: {headers: true, separator: \",\", skipLines: 0}"}], "documentation": "Parses multi-line CSV to array of objects"}, "hover": {"description": "Parses multi-line CSV into array of objects.", "signature": "csv.parsemultiline({headers, separator, skipLines})", "example": "$data: $csv | csv.parsemultiline;"}},
    {"name": "csv.findrow", "detail": "Find CSV row", "insertText": "csv.findrow"},
    {"name": "html.escape", "detail": "Escape HTML entities", "insertText": "html.escape"},
    {"name": "html.unescape", "detail": "Unescape HTML entities", "insertText": "html.unescape"},
    {"name": "Math.sum", "detail": "Sum values", "insertText": "Math.sum(${1:0})", "returns": {"type": "Number"}, "signature": {"label": "Math.sum(initialValue: number)", "parameters": [{"label": "initialValue", "documentation": "Starting value for sum (usually 0)"}], "documentation": "Sums all numbers in array"}, "hover": {"description": "Sums all numbers in an array.", "signature": "Math.sum(initialValue)", "example": "$total: $prices | Math.sum(0);"}},
    {"name": "Math.average", "detail": "Average values", "insertText": "Math.average", "hover": {"description": "Calculates the average of numbers in an array.", "signature": "Math.average", "example": "$avg: $scores | Math.average;"}},
    {"name": "Math.mean", "detail": "Mean of values", "insertText": "Math.mean"},
    {"name": "Math.min", "detail": "Minimum value", "insertText": "Math.min", "hover": {"description": "Finds the minimum value in an array.", "signature": "Math.min", "example": "$lowest: $prices | Math.min;"}},
    {"name": "Math.max", "detail": "Maximum value", "insertText": "Math.max", "hover": {"description": "Finds the maximum value in an array.", "signature": "Math.max", "example": "$highest: $scores | Math.max;"}},
    {"name": "Math.mod", "detail": "Modulo operation", "insertText": "Math.mod(${1:divisor})"},
    {"name": "Math.sqrt", "detail": "Square root", "insertText": "Math.sqrt"},
    {"name": "Math.round", "detail": "Round number", "insertText": "Math.round", "hover": {"description": "Rounds a number.", "signature": "Math.round", "example": "$rounded: $value | Math.round;"}},
    {"name": "Math.floor", "detail": "Round down", "insertText": "Math.floor", "hover": {"description": "Rounds down to nearest integer.", "signature": "Math.floor", "example": "$down: $value | Math.floor;"}},
    {"name": "Math.ceil", "detail": "Round up", "insertText": "Math.ceil", "hover": {"description": "Rounds up to nearest integer.", "signature": "Math.ceil", "example": "$up: $value | Math.ceil;"}},
    {"name": "Math.abs", "detail": "Absolute value", "insertText": "Math.abs", "hover": {"description": "Returns absolute value.", "signature": "Math.abs", "example": "$positive: $negative | Math.abs;"}},
    {"name": "Math.clamp", "detail": "Clamp value", "insertText": "Math.clamp(${1:min}, ${2:max})", "signature": {"label": "Math.clamp(min: number, max: number)", "parameters": [{"label": "min", "documentation": "Minimum allowed value"}, {"label": "max", "documentation": "Maximum allowed value"}], "documentation": "Clamps number to range [min, max]"}, "hover": {"description": "Clamps a number to a range [min, max].", "signature": "Math.clamp(min, max)", "example": "$safe: $value | Math.clamp(0, 100);"}},
    {"name": "Math.RandInt", "detail": "Random integer", "insertText": "Math.RandInt(${1:min}, ${2:max})", "signature": {"label": "Math.RandInt(min: number, max?: number)", "parameters": [{"label": "min", "documentation": "Minimum value (inclusive)"}, {"label": "max", "documentation": "Maximum value (exclusive); if omitted, 0 to min"}], "documentation": "Random integer in range"}, "hover": {"description": "Generates a random integer.", "signature": "Math.RandInt(min, max?)", "example": "$n: $x | Math.RandInt(1, 100);"}},
    {"name": "Math.RandFloat", "detail": "Random float", "insertText": "Math.RandFloat"},
    {"name": "Math.RandDouble", "detail": "Random double", "insertText": "Math.RandDouble", "signature": {"label": "Math.RandDouble(min?: number, max?: number)", "parameters": [{"label": "min", "documentation": "Minimum (optional)"}, {"label": "max", "documentation": "Maximum (optional)"}], "documentation": "Random double in range or [0,1)"}},
    {"name": "Math.log", "detail": "Logarithm (base e or custom)", "insertText": "Math.log(${1:base})", "signature": {"label": "Math.log(base?: number)", "parameters": [{"label": "base", "documentation": "Optional base; default is e (natural log)"}], "documentation": "Natural log or log with given base"}, "hover": {"description": "Natural logarithm or logarithm with custom base.", "signature": "Math.log(base?)", "example": "$y: $x | Math.log;"}},
    {"name": "Math.log10", "detail": "Logarithm base 10", "insertText": "Math.log10", "hover": {"description": "Base-10 logarithm.", "signature": "Math.log10", "example": "$y: $x | Math.log10;"}},
    {"name": "Math.ln", "detail": "Natural logarithm", "insertText": "Math.ln", "hover": {"description": "Natural logarithm (base e).", "signature": "Math.ln", "example": "$y: $x | Math.ln;"}},
    {"name": "Math.pow", "detail": "Power (value^exponent)", "insertText": "Math.pow(${1:exponent})", "signature": {"label": "Math.pow(exponent: number)", "parameters": [{"label": "exponent", "documentation": "Exponent"}], "documentation": "Raises value to exponent"}, "hover": {"description": "Raises value to the given exponent.", "signature": "Math.pow(exponent)", "example": "$sq: $x | Math.pow(2);"}},
    {"name": "negate", "detail": "Negate number", "insertText": "negate"},
    {"name": "absolute", "detail": "Absolute value", "insertText": "absolute"},
    {"name": "precision", "detail": "Set decimal precision", "insertText": "precision(${1:2})", "signature": {"label": "precision(digits: number)", "parameters": [{"label": "digits", "documentation": "Number of decimal places"}], "documentation": "Sets decimal precision (e.g., precision(2) â†’ 12.99)"}, "hover": {"description": "Sets decimal precision for a number.", "signature": "precision(digits)", "example": "$price: $value | precision(2);"}},
    {"name": "round.up", "detail": "Round up", "insertText": "round.up(${1:2})", "signature": {"label": "round.up(precision?: number)", "parameters": [{"label": "precision", "documentation": "Decimal places (default 2)"}], "documentation": "Rounds up to given precision"}, "hover": {"description": "Rounds a number up.", "signature": "round.up(precision?)", "example": "$val: $num | round.up(2);"}},
    {"name": "round.down", "detail": "Round down", "insertText": "round.down(${1:2})", "signature": {"label": "round.down(precision?: number)", "parameters": [{"label": "precision", "documentation": "Decimal places (default 2)"}], "documentation": "Rounds down to given precision"}, "hover": {"description": "Rounds a number down.", "signature": "round.down(precision?)", "example": "$val: $num | round.down(2);"}},
    {"name": "round.ceiling", "detail": "Round ceiling", "insertText": "round.ceiling(${1:2})"},
    {"name": "round.floor", "detail": "Round floor", "insertText": "round.floor(${1:2})"},
    {"name": "round.half", "detail": "Round half (half-even)", "insertText": "round.half(${1:2})"},
    {"name": "keys", "detail": "Get object keys", "insertText": "keys", "returns": {"type": "Array"}, "hover": {"description": "Returns an array of object keys.", "signature": "keys", "example": "$propNames: $object | keys;"}},
    {"name": "kv", "detail": "Key-value pairs", "insertText": "kv", "documentation": "Converts object to [{key, value}] array", "hover": {"description": "Converts object to array of key-value pairs.", "signature": "kv", "example": "$pairs: $object | kv;"}},
    {"name": "delete", "detail": "Delete property", "insertText": "delete(\"${1:property}\")", "signature": {"label": "delete(propertyName: string)", "parameters": [{"label": "propertyName", "documentation": "Name of property to delete"}], "documentation": "Removes property from object"}, "hover": {"description": "Removes a property from an object.", "signature": "delete(propertyName)", "example": "$clean: $object | delete(\"tempField\");"}},
    {"name": "select", "detail": "Select by JSON path", "insertText": "select(\"${1:path}\")", "documentation": "Example: select(\"user.address.city\")", "signature": {"label": "select(path: string)", "parameters": [{"label": "path", "documentation": "Property path (e.g., \"user.address.city\")"}], "documentation": "Selects nested property by path"}, "hover": {"description": "Selects a nested property by path.", "signature": "select(path)", "example": "$value: $object | select(\"user.address.city\");"}},
    {"name": "getProperty", "detail": "Get property (case-insensitive)", "insertText": "getProperty(\"${1:name}\")", "signature": {"label": "getProperty(name: string)", "parameters": [{"label": "name", "documentation": "Property name (case-insensitive)"}], "documentation": "Gets property by name (case-insensitive lookup)"}, "hover": {"description": "Gets a property by name (case-insensitive).", "signature": "getProperty(name)", "example": "$value: $object | getProperty(\"Name\");"}},
    {"name": "setProperty", "detail": "Set property", "insertText": "setProperty(\"${1:name}\", ${2:value})"},
    {"name": "merge", "detail": "Merge objects", "insertText": "merge(${1:\\$other})"},
    {"name": "pick", "detail": "Pick properties", "insertText": "pick(\"${1:prop1}\", \"${2:prop2}\")"},
    {"name": "omit", "detail": "Omit properties", "insertText": "omit(\"${1:prop1}\", \"${2:prop2}\")"},
    {"name": "rename", "detail": "Rename property", "insertText": "rename(\"${1:oldName}\", \"${2:newName}\")"},
    {"name": "has", "detail": "Check if has property", "insertText": "has(\"${1:property}\")"},
    {"name": "default", "detail": "Default value if null/empty", "insertText": "default(${1:value})", "signature": {"label": "default(defaultValue: any)", "parameters": [{"label": "defaultValue", "documentation": "Value to use if input is null/empty"}], "documentation": "Returns default value if input is null or empty"}, "hover": {"description": "Returns a default value if the input is null or empty.", "signature": "default(defaultValue)", "example": "$name: $input.name | default(\"Unknown\");"}},
    {"name": "regex.find", "detail": "Find regex matches", "insertText": "regex.find(\"${1:pattern}\")", "signature": {"label": "regex.find(pattern: string, options?: object)", "parameters": [{"label": "pattern", "documentation": "Regular expression pattern"}, {"label": "options", "documentation": "Optional: {ignoreCase: true, multiLine: true}"}], "documentation": "Finds all matches of pattern in string"}, "hover": {"description": "Finds all matches of pattern in string.", "signature": "regex.find(pattern)", "example": "$found: $text | regex.find(\"/\\\\d+/\");"}},
    {"name": "regex.matches", "detail": "Test regex match", "insertText": "regex.matches(\"${1:pattern}\")", "returns": {"type": "Boolean"}, "signature": {"label": "regex.matches(pattern: string, options?: object)", "parameters": [{"label": "pattern", "documentation": "Regular expression pattern"}, {"label": "options", "documentation": "Optional: {ignoreCase: true}"}], "documentation": "Tests if pattern matches string (returns boolean)"}},
    {"name": "regex.replace", "detail": "Replace with regex", "insertText": "regex.replace(\"${1:pattern}\", \"${2:replacement}\")", "signature": {"label": "regex.replace(pattern: string, replacement: string, options?: object)", "parameters": [{"label": "pattern", "documentation": "Regular expression pattern"}, {"label": "replacement", "documentation": "Replacement string"}, {"label": "options", "documentation": "Optional: {ignoreCase: true}"}], "documentation": "Replaces pattern matches with replacement"}},
    {"name": "regex.replacefirst", "detail": "Replace first match", "insertText": "regex.replacefirst(\"${1:pattern}\", \"${2:replacement}\")"},
    {"name": "encode.base64", "detail": "Base64 encode", "insertText": "encode.base64", "signature": {"label": "encode.base64(options?: object)", "parameters": [{"label": "options", "documentation": "Optional {withoutPadding: true}"}], "documentation": "Encodes to Base64 string"}, "hover": {"description": "Encodes value to Base64 string.", "signature": "encode.base64(options?)", "example": "$b64: $bytes | encode.base64;"}},
    {"name": "encode.base64url", "detail": "Base64 URL encode", "insertText": "encode.base64url", "signature": {"label": "encode.base64url(options?: object)", "parameters": [{"label": "options", "documentation": "Optional {withoutPadding: true}"}], "documentation": "Encodes to Base64 URL-safe string"}, "hover": {"description": "Encodes to Base64 URL-safe string.", "signature": "encode.base64url(options?)", "example": "$b64: $bytes | encode.base64url;"}},
    {"name": "encode.path", "detail": "URL path encode", "insertText": "encode.path"},
    {"name": "encode.query", "detail": "URL query encode", "insertText": "encode.query"},
    {"name": "decode.base64", "detail": "Base64 decode", "insertText": "decode.base64"},
    {"name": "decode.base64url", "detail": "Base64 URL decode", "insertText": "decode.base64url"},
    {"name": "decode.query", "detail": "URL query decode", "insertText": "decode.query"},
    {"name": "hex.tobinary", "detail": "Convert hex to binary", "insertText": "hex.tobinary"},
    {"name": "join.string", "detail": "Join array to string", "insertText": "join.string(\"${1:,}\")", "signature": {"label": "join.string(itemDelimiter?: string, fieldDelimiter?: string)", "parameters": [{"label": "itemDelimiter", "documentation": "Between items (default \",\")"}, {"label": "fieldDelimiter", "documentation": "Between key=value (for objects, default \"=\")"}], "documentation": "Joins array or object to string"}, "hover": {"description": "Joins array elements to string. For objects: encoding is first param (string/path/query), then delimiters.", "signature": "join.string(delimiter?)", "example": "$s: $arr | join.string(\", \");"}},
    {"name": "join.path", "detail": "Join for URL path encoding", "insertText": "join.path(\"${1:&}\")", "signature": {"label": "join.path(itemDelimiter?: string)", "parameters": [{"label": "itemDelimiter", "documentation": "Between items"}], "documentation": "Joins with path encoding"}, "hover": {"description": "Joins array/object with URL path encoding.", "signature": "join.path(delimiter?)", "example": "$path: $segments | join.path;"}},
    {"name": "join.query", "detail": "Join for URL query encoding", "insertText": "join.query(\"${1:&}\")", "signature": {"label": "join.query(itemDelimiter?: string)", "parameters": [{"label": "itemDelimiter", "documentation": "Between key=value pairs"}], "documentation": "Joins with query encoding"}, "hover": {"description": "Joins object to query string with encoding.", "signature": "join.query(delimiter?)", "example": "$qs: $params | join.query(\"&\");"}},
    {"name": "email.parse", "detail": "Parse email addresses", "insertText": "email.parse"},
    {"name": "gzip", "detail": "GZip compress", "insertText": "gzip(\"${1:UTF-8}\")", "signature": {"label": "gzip(charset?: string)", "parameters": [{"label": "charset", "documentation": "Charset for string input (default UTF-8)"}], "documentation": "Compresses to gzip bytes"}, "hover": {"description": "Compresses string to gzip byte array.", "signature": "gzip(charset?)", "example": "$compressed: $text | gzip;"}},
    {"name": "gunzip", "detail": "GZip decompress", "insertText": "gunzip(\"${1:UTF-8}\")", "signature": {"label": "gunzip(charset?: string)", "parameters": [{"label": "charset", "documentation": "Charset for output string (default UTF-8)"}], "documentation": "Decompresses gzip bytes to string"}, "hover": {"description": "Decompresses gzip bytes to string.", "signature": "gunzip(charset?)", "example": "$text: $bytes | gunzip;"}},
    {"name": "gunzipToByte", "detail": "GZip decompress to bytes", "insertText": "gunzipToByte"},
    {"name": "Crypto.sha256", "detail": "SHA-256 hash (bytes)", "insertText": "Crypto.sha256"},
    {"name": "Crypto.sha512", "detail": "SHA-512 hash (bytes)", "insertText": "Crypto.sha512"},
    {"name": "Crypto.sha1", "detail": "SHA-1 hash (bytes)", "insertText": "Crypto.sha1"},
    {"name": "Crypto.md5", "detail": "MD5 hash (bytes)", "insertText": "Crypto.md5"},
    {"name": "Crypto.hmacsha256", "detail": "HMAC-SHA256", "insertText": "Crypto.hmacsha256(${1:key})", "signature": {"label": "Crypto.hmacsha256(key)", "parameters": [{"label": "key", "documentation": "Secret key (bytes)"}], "documentation": "HMAC with SHA-256"}, "hover": {"description": "Computes HMAC-SHA256. Input and key are from pipe/args.", "signature": "Crypto.hmacsha256(key)", "example": "$sig: $payload | Crypto.hmacsha256($key);"}},
    {"name": "Crypto.hmacsha384", "detail": "HMAC-SHA384", "insertText": "Crypto.hmacsha384(${1:key})"},
    {"name": "Crypto.hmacsha512", "detail": "HMAC-SHA512", "insertText": "Crypto.hmacsha512(${1:key})"},
    {"name": "Crypto.hmacsha1", "detail": "HMAC-SHA1", "insertText": "Crypto.hmacsha1(${1:key})"},
    {"name": "Crypto.rsasha256", "detail": "RSA-SHA256 sign", "insertText": "Crypto.rsasha256(${1:keyStore}, ${2:password}, ${3:keyAlias})"},
    {"name": "Crypto.tokeystore", "detail": "Load key store from Base64", "insertText": "Crypto.tokeystore(${1:type}, ${2:password})", "signature": {"label": "Crypto.tokeystore(keystoreType: string, password: string)", "parameters": [{"label": "keystoreType", "documentation": "KeyStore type"}, {"label": "password", "documentation": "KeyStore password"}], "documentation": "Decodes Base64 key store bytes"}, "hover": {"description": "Loads a KeyStore from Base64-encoded bytes.", "signature": "Crypto.tokeystore(type, password)", "example": "$ks: $b64 | Crypto.tokeystore(\"PKCS12\", \"secret\");"}},
    {"name": "Crypto.aes256gcm", "detail": "AES-256-GCM decrypt", "insertText": "Crypto.aes256gcm(${1:key}, ${2:iv}, ${3:tag})"},
    {"name": "Crypto.decrypt", "detail": "JWE decrypt", "insertText": "Crypto.decrypt(${1:algorithm}, ${2:keyMaterial})", "signature": {"label": "Crypto.decrypt(algorithm: string, keyMaterial: string)", "parameters": [{"label": "algorithm", "documentation": "e.g. RSA_OAEP_256"}, {"label": "keyMaterial", "documentation": "Private key PEM or JWK"}], "documentation": "Decrypts JWE payload"}, "hover": {"description": "Decrypts a JWE payload with private key.", "signature": "Crypto.decrypt(algorithm, keyMaterial)", "example": "$plain: $jwe | Crypto.decrypt(\"RSA_OAEP_256\", $privateKey);"}},
    {"name": "Crypto.verify", "detail": "JWS verify", "insertText": "Crypto.verify(${1:algorithm}, ${2:keyMaterial})", "signature": {"label": "Crypto.verify(algorithm: string, keyMaterial: string)", "parameters": [{"label": "algorithm", "documentation": "e.g. RS256"}, {"label": "keyMaterial", "documentation": "Public key PEM or JWK"}], "documentation": "Verifies JWS and returns payload"}, "hover": {"description": "Verifies a JWS and returns the payload.", "signature": "Crypto.verify(algorithm, keyMaterial)", "example": "$payload: $jws | Crypto.verify(\"RS256\", $publicKey);"}},
    {"name": "zip.add", "detail": "Add file to zip", "insertText": "zip.add(\"${1:fileName}\", ${2:content})", "signature": {"label": "zip.add(fileName: string, content: any, charset?: string)", "parameters": [{"label": "fileName", "documentation": "Entry name in zip"}, {"label": "content", "documentation": "File content (string or bytes)"}, {"label": "charset", "documentation": "Optional charset for string content (default UTF-8)"}], "documentation": "Adds a file to the ZipObject"}, "hover": {"description": "Adds a file to an open zip (from @.Zip.Start()).", "signature": "zip.add(fileName, content, charset?)", "example": "@.Zip.Start() | zip.add(\"foo.txt\", \"hello\") | zip.close;"}},
    {"name": "zip.close", "detail": "Close zip and get bytes", "insertText": "zip.close"},
    {"name": "zip.inflate", "detail": "Inflate (decompress deflate)", "insertText": "zip.inflate"},
    {"name": "zip.deflate", "detail": "Deflate (compress)", "insertText": "zip.deflate"},
    {"name": "unzip", "detail": "Unzip byte array to entries", "insertText": "unzip", "returns": {"type": "Array"}, "signature": {"label": "unzip", "parameters": [], "documentation": "Returns array of {name, content} for each entry"}, "hover": {"description": "Unzips a byte array to an array of {name, content}.", "signature": "unzip", "example": "$entries: $zippedBytes | unzip;"}},
    {"name": "retry.when", "detail": "Retry when condition", "insertText": "retry.when({{ ${1:condition} }}, { retryCount: ${2:3}, backOff: ${3:false} })", "signature": {"label": "retry.when(condition, options?)", "parameters": [{"label": "condition", "documentation": "Expression; if true after execution, retries"}, {"label": "options", "documentation": "{retryCount, delay, delayFrom, delayTo, backOff}"}], "documentation": "Conditional retry with options"}, "hover": {"description": "Retries while condition is true. Options: retryCount, delay, backOff.", "signature": "retry.when(condition, options)", "example": "$x: retry.when({{ $.status == \"pending\" }}, { retryCount: 3 });"}},
    {"name": "typeof", "detail": "Get type of value", "insertText": "typeof"}
  ],
  "functions": [
    {"namespace": "Date", "name": "now", "detail": "Get current date/time", "params": "()", "returns": {"type": "Date"}, "documentation": "Returns the current date and time in UTC.", "signature": {"label": "@.Date.Now()", "parameters": [], "documentation": "Returns current date/time in UTC"}},
    {"namespace": "Date", "name": "parse", "detail": "Parse date string", "params": "(string, format)", "returns": {"type": "Date"}, "documentation": "Parses a date string using the specified format.", "signature": {"label": "@.Date.parse(dateString: string, format: string, options?: object)", "parameters": [{"label": "dateString", "documentation": "String containing the date to parse"}, {"label": "format", "documentation": "Date format pattern (e.g., \"yyyy-MM-dd\")"}, {"label": "options", "documentation": "Optional: {locale: \"en_US\"}"}], "documentation": "Parses a date string into a date object"}},
    {"namespace": "Date", "name": "format", "detail": "Format date", "params": "(date, format)"},
    {"namespace": "Date", "name": "fromEpochSeconds", "detail": "Create date from epoch seconds", "params": "(seconds)", "returns": {"type": "Date"}, "documentation": "Creates a date from Unix epoch seconds.", "signature": {"label": "@.Date.fromEpochSeconds(seconds: number)", "parameters": [{"label": "seconds", "documentation": "Unix timestamp in seconds"}], "documentation": "Creates date from Unix timestamp (seconds)"}},
    {"namespace": "Date", "name": "fromEpochMillis", "detail": "Create date from epoch milliseconds", "params": "(millis)", "returns": {"type": "Date"}, "documentation": "Creates a date from Unix epoch milliseconds.", "signature": {"label": "@.Date.fromEpochMillis(milliseconds: number)", "parameters": [{"label": "milliseconds", "documentation": "Unix timestamp in milliseconds"}], "documentation": "Creates date from Unix timestamp (milliseconds)"}},
    {"namespace": "Math", "name": "sum", "detail": "Sum values in array", "params": "(initial)", "returns": {"type": "Number"}, "documentation": "Sums all values in an array. Use with pipe: `$prices | Math.sum(0)`", "signature": {"label": "@.Math.sum(array: number[], initialValue: number)", "parameters": [{"label": "array", "documentation": "Array of numbers to sum"}, {"label": "initialValue", "documentation": "Starting value (usually 0)"}], "documentation": "Sums all numbers in array"}},
    {"namespace": "Math", "name": "mean", "detail": "Calculate mean (average of array)", "params": "()", "returns": {"type": "Number"}, "documentation": "Average of numbers in array. Use with pipe: $arr | Math.mean", "signature": {"label": "@.Math.mean()", "parameters": [], "documentation": "Mean of array (pipe input)"}},
    {"namespace": "Math", "name": "min", "detail": "Find minimum value", "params": "()", "returns": {"type": "Number"}},
    {"namespace": "Math", "name": "max", "detail": "Find maximum value", "params": "()", "returns": {"type": "Number"}},
    {"namespace": "Math", "name": "mod", "detail": "Modulo operation", "params": "(divisor)"},
    {"namespace": "Math", "name": "sqrt", "detail": "Square root", "params": "()", "returns": {"type": "Number"}, "documentation": "Square root. Use with pipe: $x | Math.sqrt"},
    {"namespace": "Math", "name": "clamp", "detail": "Clamp value between min and max", "params": "(min, max)", "signature": {"label": "@.Math.clamp(value: number, min: number, max: number)", "parameters": [{"label": "value", "documentation": "Number to clamp (pipe input)"}, {"label": "min", "documentation": "Minimum allowed value"}, {"label": "max", "documentation": "Maximum allowed value"}], "documentation": "Clamps value to range [min, max]"}},
    {"namespace": "Math", "name": "RandInt", "detail": "Random integer", "params": "(min, max)", "documentation": "Generates a random integer between min and max (inclusive)."},
    {"namespace": "Math", "name": "RandFloat", "detail": "Random float", "params": "()"},
    {"namespace": "Math", "name": "RandDouble", "detail": "Random double", "params": "(min?, max?)", "documentation": "Random double; optional min/max range.", "signature": {"label": "@.Math.RandDouble(min?: number, max?: number)", "parameters": [{"label": "min", "documentation": "Optional minimum"}, {"label": "max", "documentation": "Optional maximum"}], "documentation": "Random double in [0,1) or [min,max)"}},
    {"namespace": "Math", "name": "log", "detail": "Logarithm (base e or custom)", "params": "(base?)", "returns": {"type": "Number"}, "documentation": "Natural log or log with given base. Use with pipe: $x | Math.log or Math.log(base)", "signature": {"label": "@.Math.log(base?: number)", "parameters": [{"label": "base", "documentation": "Optional base (default e)"}], "documentation": "Natural log or custom base"}},
    {"namespace": "Math", "name": "log10", "detail": "Log base 10", "params": "()", "returns": {"type": "Number"}, "documentation": "Base-10 logarithm. Use with pipe: $x | Math.log10"},
    {"namespace": "Math", "name": "ln", "detail": "Natural logarithm", "params": "()", "returns": {"type": "Number"}, "documentation": "Natural log (base e). Use with pipe: $x | Math.ln"},
    {"namespace": "Math", "name": "pow", "detail": "Power (value^exponent)", "params": "(exponent)", "returns": {"type": "Number"}, "documentation": "Raises value to exponent. Use with pipe: $x | Math.pow(2)", "signature": {"label": "@.Math.pow(exponent: number)", "parameters": [{"label": "exponent", "documentation": "Exponent"}], "documentation": "Value to the power of exponent"}},
    {"namespace": "Run", "name": "Sleep", "detail": "Sleep milliseconds", "params": "(ms)", "documentation": "Pauses execution for given milliseconds. Use: @.Run.Sleep(1000)", "signature": {"label": "@.Run.Sleep(milliseconds: number)", "parameters": [{"label": "milliseconds", "documentation": "Delay in ms"}], "documentation": "Async sleep"}},
    {"namespace": "UUID", "name": "New", "detail": "Generate new UUID", "params": "()", "returns": {"type": "String"}, "documentation": "Returns a new UUID string. Use: @.UUID.New()", "signature": {"label": "@.UUID.New()", "parameters": [], "documentation": "New UUID string"}},
    {"namespace": "Zip", "name": "Start", "detail": "Create new zip object", "params": "()", "returns": {"type": "Object"}, "documentation": "Creates an empty zip for zip.add/zip.close. Use: @.Zip.Start() | zip.add(\"f.txt\", $content) | zip.close", "signature": {"label": "@.Zip.Start()", "parameters": [], "documentation": "New ZipObject for building zip"}},
    {"namespace": "String", "name": "concat", "detail": "Concatenate strings", "params": "(...)", "signature": {"label": "@.String.concat(...strings: string[])", "parameters": [{"label": "strings", "documentation": "Strings to concatenate"}], "documentation": "Concatenates multiple strings"}},
    {"namespace": "String", "name": "join", "detail": "Join array with separator", "params": "(array, sep)", "signature": {"label": "@.String.join(array: string[], separator: string)", "parameters": [{"label": "array", "documentation": "Array of strings to join"}, {"label": "separator", "documentation": "Separator string (e.g., \", \")"}], "documentation": "Joins array elements into string"}},
    {"namespace": "String", "name": "split", "detail": "Split string", "params": "(str, sep)", "signature": {"label": "@.String.split(string: string, separator: string)", "parameters": [{"label": "string", "documentation": "String to split"}, {"label": "separator", "documentation": "Separator pattern"}], "documentation": "Splits string into array"}},
    {"namespace": "Array", "name": "from", "detail": "Create array from", "params": "(...)"},
    {"namespace": "Array", "name": "of", "detail": "Create array of", "params": "(...)"},
    {"namespace": "Array", "name": "range", "detail": "Generate range", "params": "(start, count, increment)", "documentation": "Generates an array of numbers. Example: `@.Array.range(0, 10, 1)` creates [0, 1, 2, ..., 9]"},
    {"namespace": "Array", "name": "slice", "detail": "Slice array", "params": "(start, end)"},
    {"namespace": "Array", "name": "unique", "detail": "Unique values", "params": "()"},
    {"namespace": "Json", "name": "parse", "detail": "Parse JSON string", "params": "(string)", "returns": {"type": "Object"}, "signature": {"label": "@.Json.parse(jsonString: string)", "parameters": [{"label": "jsonString", "documentation": "JSON string to parse"}], "documentation": "Parses JSON string into object"}},
    {"namespace": "Json", "name": "stringify", "detail": "Stringify to JSON", "params": "(object)", "returns": {"type": "String"}, "signature": {"label": "@.Json.stringify(object: any)", "parameters": [{"label": "object", "documentation": "Object to convert to JSON"}], "documentation": "Converts object to JSON string"}},
    {"namespace": "Xml", "name": "parse", "detail": "Parse XML string", "params": "(string)", "returns": {"type": "Object"}, "signature": {"label": "@.Xml.parse(xmlString: string)", "parameters": [{"label": "xmlString", "documentation": "XML string to parse"}], "documentation": "Parses XML string into JSON object"}},
    {"namespace": "Xml", "name": "toXml", "detail": "Convert to XML", "params": "(object, rootName)", "signature": {"label": "@.Xml.toXml(object: any, rootName: string)", "parameters": [{"label": "object", "documentation": "Object to convert"}, {"label": "rootName", "documentation": "Root element name"}], "documentation": "Converts object to XML string"}},
    {"namespace": "Yaml", "name": "parse", "detail": "Parse YAML", "params": "(string)"},
    {"namespace": "Crypto", "name": "md5", "detail": "MD5 hash", "params": "(string)", "returns": {"type": "String"}, "signature": {"label": "@.Crypto.md5(string: string)", "parameters": [{"label": "string", "documentation": "String to hash"}], "documentation": "Computes MD5 hash (returns hex string)"}},
    {"namespace": "Crypto", "name": "sha1", "detail": "SHA-1 hash", "params": "(string)", "returns": {"type": "String"}, "signature": {"label": "@.Crypto.sha1(string: string)", "parameters": [{"label": "string", "documentation": "String to hash"}], "documentation": "Computes SHA-1 hash (returns hex string)"}},
    {"namespace": "Crypto", "name": "sha256", "detail": "SHA-256 hash", "params": "(string)", "returns": {"type": "String"}, "signature": {"label": "@.Crypto.sha256(string: string)", "parameters": [{"label": "string", "documentation": "String to hash"}], "documentation": "Computes SHA-256 hash (returns hex string)"}},
    {"namespace": "Crypto", "name": "base64encode", "detail": "Base64 encode", "params": "(string)", "returns": {"type": "String"}, "signature": {"label": "@.Crypto.base64encode(string: string)", "parameters": [{"label": "string", "documentation": "String to encode"}], "documentation": "Encodes string to Base64"}},
    {"namespace": "Crypto", "name": "base64decode", "detail": "Base64 decode", "params": "(string)", "returns": {"type": "String"}, "signature": {"label": "@.Crypto.base64decode(string: string)", "parameters": [{"label": "string", "documentation": "Base64 string to decode"}], "documentation": "Decodes Base64 string"}},
    {"namespace": "Pagination", "name": "Cursor", "detail": "Cursor pagination", "params": "()", "documentation": "Statement: Cursor-based pagination. Registered in runtime."},
    {"namespace": "Pagination", "name": "Page", "detail": "Page pagination", "params": "()", "documentation": "Statement: Page-based pagination. Registered in runtime."},
    {"namespace": "Pagination", "name": "Date", "detail": "Date pagination", "params": "()", "documentation": "Statement: Date-based pagination. Registered in runtime."},
    {"namespace": "Assert", "name": "equal", "detail": "Assert expected equals actual", "params": "(expected, actual, message?)", "returns": {"type": "null"}, "documentation": "Asserts that expected equals actual (deep equality). Throws on failure. Optional third parameter: custom message.", "signature": {"label": "@.Assert.equal(expected: any, actual: any, message?: string)", "parameters": [{"label": "expected", "documentation": "Expected value"}, {"label": "actual", "documentation": "Actual value to compare"}, {"label": "message", "documentation": "Optional custom failure message"}], "documentation": "Asserts deep equality between expected and actual"}},
    {"namespace": "Assert", "name": "notEqual", "detail": "Assert expected not equals actual", "params": "(expected, actual, message?)", "returns": {"type": "null"}, "documentation": "Asserts that expected does not equal actual. Throws on failure.", "signature": {"label": "@.Assert.notEqual(expected: any, actual: any, message?: string)", "parameters": [{"label": "expected", "documentation": "Value that should not match"}, {"label": "actual", "documentation": "Actual value to compare"}, {"label": "message", "documentation": "Optional custom failure message"}], "documentation": "Asserts values are not equal"}},
    {"namespace": "Assert", "name": "notNull", "detail": "Assert value is not null", "params": "(value, message?)", "returns": {"type": "null"}, "documentation": "Asserts that the value is not null. Throws on failure.", "signature": {"label": "@.Assert.notNull(value: any, message?: string)", "parameters": [{"label": "value", "documentation": "Value that must not be null"}, {"label": "message", "documentation": "Optional custom failure message"}], "documentation": "Asserts value is not null"}},
    {"namespace": "Assert", "name": "isNull", "detail": "Assert value is null", "params": "(value, message?)", "returns": {"type": "null"}, "documentation": "Asserts that the value is null. Throws on failure.", "signature": {"label": "@.Assert.isNull(value: any, message?: string)", "parameters": [{"label": "value", "documentation": "Value that must be null"}, {"label": "message", "documentation": "Optional custom failure message"}], "documentation": "Asserts value is null"}},
    {"namespace": "Assert", "name": "lessThan", "detail": "Assert expected < actual", "params": "(expected, actual, message?)", "returns": {"type": "null"}, "documentation": "Asserts expected is less than actual.", "signature": {"label": "@.Assert.lessThan(expected: any, actual: any, message?: string)", "parameters": [{"label": "expected", "documentation": "Expected (left) value"}, {"label": "actual", "documentation": "Actual (right) value"}, {"label": "message", "documentation": "Optional custom failure message"}], "documentation": "Asserts expected < actual"}},
    {"namespace": "Assert", "name": "lessThanOrEqual", "detail": "Assert expected <= actual", "params": "(expected, actual, message?)", "returns": {"type": "null"}, "documentation": "Asserts expected is less than or equal to actual.", "signature": {"label": "@.Assert.lessThanOrEqual(expected: any, actual: any, message?: string)", "parameters": [{"label": "expected", "documentation": "Expected value"}, {"label": "actual", "documentation": "Actual value"}, {"label": "message", "documentation": "Optional custom failure message"}], "documentation": "Asserts expected <= actual"}},
    {"namespace": "Assert", "name": "greaterThan", "detail": "Assert expected > actual", "params": "(expected, actual, message?)", "returns": {"type": "null"}, "documentation": "Asserts expected is greater than actual.", "signature": {"label": "@.Assert.greaterThan(expected: any, actual: any, message?: string)", "parameters": [{"label": "expected", "documentation": "Expected value"}, {"label": "actual", "documentation": "Actual value"}, {"label": "message", "documentation": "Optional custom failure message"}], "documentation": "Asserts expected > actual"}},
    {"namespace": "Assert", "name": "greaterThanOrEqual", "detail": "Assert expected >= actual", "params": "(expected, actual, message?)", "returns": {"type": "null"}, "documentation": "Asserts expected is greater than or equal to actual.", "signature": {"label": "@.Assert.greaterThanOrEqual(expected: any, actual: any, message?: string)", "parameters": [{"label": "expected", "documentation": "Expected value"}, {"label": "actual", "documentation": "Actual value"}, {"label": "message", "documentation": "Optional custom failure message"}], "documentation": "Asserts expected >= actual"}},
    {"namespace": "Assert", "name": "matches", "detail": "Assert string matches regex", "params": "(regex, string, message?)", "returns": {"type": "null"}, "documentation": "Asserts that the string matches the regex pattern (case-insensitive).", "signature": {"label": "@.Assert.matches(regex: string, string: string, message?: string)", "parameters": [{"label": "regex", "documentation": "Regex pattern"}, {"label": "string", "documentation": "String to test"}, {"label": "message", "documentation": "Optional custom failure message"}], "documentation": "Asserts string matches regex"}},
    {"namespace": "Assert", "name": "notMatches", "detail": "Assert string does not match regex", "params": "(regex, string, message?)", "returns": {"type": "null"}, "documentation": "Asserts that the string does not match the regex pattern.", "signature": {"label": "@.Assert.notMatches(regex: string, string: string, message?: string)", "parameters": [{"label": "regex", "documentation": "Regex pattern"}, {"label": "string", "documentation": "String to test"}, {"label": "message", "documentation": "Optional custom failure message"}], "documentation": "Asserts string does not match regex"}},
    {"namespace": "Assert", "name": "contains", "detail": "Assert container contains item", "params": "(container, item, message?)", "returns": {"type": "null"}, "documentation": "Asserts container (string or array) contains item.", "signature": {"label": "@.Assert.contains(container: string|array, item: any, message?: string)", "parameters": [{"label": "container", "documentation": "String or array to search in"}, {"label": "item", "documentation": "Item or substring to find"}, {"label": "message", "documentation": "Optional custom failure message"}], "documentation": "Asserts container contains item"}},
    {"namespace": "Assert", "name": "notContains", "detail": "Assert container does not contain item", "params": "(container, item, message?)", "returns": {"type": "null"}, "documentation": "Asserts container (string or array) does not contain item.", "signature": {"label": "@.Assert.notContains(container: string|array, item: any, message?: string)", "parameters": [{"label": "container", "documentation": "String or array"}, {"label": "item", "documentation": "Item or substring that must not be present"}, {"label": "message", "documentation": "Optional custom failure message"}], "documentation": "Asserts container does not contain item"}},
    {"namespace": "Assert", "name": "startsWith", "detail": "Assert string starts with prefix", "params": "(prefix, string, message?)", "returns": {"type": "null"}, "documentation": "Asserts that the string starts with the given prefix.", "signature": {"label": "@.Assert.startsWith(prefix: string, string: string, message?: string)", "parameters": [{"label": "prefix", "documentation": "Expected prefix"}, {"label": "string", "documentation": "String to test"}, {"label": "message", "documentation": "Optional custom failure message"}], "documentation": "Asserts string starts with prefix"}},
    {"namespace": "Assert", "name": "notStartsWith", "detail": "Assert string does not start with prefix", "params": "(prefix, string, message?)", "returns": {"type": "null"}, "documentation": "Asserts that the string does not start with the given prefix.", "signature": {"label": "@.Assert.notStartsWith(prefix: string, string: string, message?: string)", "parameters": [{"label": "prefix", "documentation": "Prefix that must not match"}, {"label": "string", "documentation": "String to test"}, {"label": "message", "documentation": "Optional custom failure message"}], "documentation": "Asserts string does not start with prefix"}},
    {"namespace": "Assert", "name": "endsWith", "detail": "Assert string ends with suffix", "params": "(suffix, string, message?)", "returns": {"type": "null"}, "documentation": "Asserts that the string ends with the given suffix.", "signature": {"label": "@.Assert.endsWith(suffix: string, string: string, message?: string)", "parameters": [{"label": "suffix", "documentation": "Expected suffix"}, {"label": "string", "documentation": "String to test"}, {"label": "message", "documentation": "Optional custom failure message"}], "documentation": "Asserts string ends with suffix"}},
    {"namespace": "Assert", "name": "notEndsWith", "detail": "Assert string does not end with suffix", "params": "(suffix, string, message?)", "returns": {"type": "null"}, "documentation": "Asserts that the string does not end with the given suffix.", "signature": {"label": "@.Assert.notEndsWith(suffix: string, string: string, message?: string)", "parameters": [{"label": "suffix", "documentation": "Suffix that must not match"}, {"label": "string", "documentation": "String to test"}, {"label": "message", "documentation": "Optional custom failure message"}], "documentation": "Asserts string does not end with suffix"}},
    {"namespace": "Assert", "name": "in", "detail": "Assert value is in collection", "params": "(value, collection, message?)", "returns": {"type": "null"}, "documentation": "Asserts that value is contained in collection (array or string).", "signature": {"label": "@.Assert.in(value: any, collection: array|string, message?: string)", "parameters": [{"label": "value", "documentation": "Value to find"}, {"label": "collection", "documentation": "Array or string to search in"}, {"label": "message", "documentation": "Optional custom failure message"}], "documentation": "Asserts value in collection"}},
    {"namespace": "Assert", "name": "notIn", "detail": "Assert value is not in collection", "params": "(value, collection, message?)", "returns": {"type": "null"}, "documentation": "Asserts that value is not contained in collection.", "signature": {"label": "@.Assert.notIn(value: any, collection: array|string, message?: string)", "parameters": [{"label": "value", "documentation": "Value that must not be in collection"}, {"label": "collection", "documentation": "Array or string"}, {"label": "message", "documentation": "Optional custom failure message"}], "documentation": "Asserts value not in collection"}},
    {"namespace": "Assert", "name": "isType", "detail": "Assert value is of type", "params": "(value, typeName, message?)", "returns": {"type": "null"}, "documentation": "Asserts value is of the given type. Types: number, date, string, node, array, boolean.", "signature": {"label": "@.Assert.isType(value: any, typeName: string, message?: string)", "parameters": [{"label": "value", "documentation": "Value to check"}, {"label": "typeName", "documentation": "Type: number, date, string, node, array, boolean"}, {"label": "message", "documentation": "Optional custom failure message"}], "documentation": "Asserts value is of type"}},
    {"namespace": "Assert", "name": "isNotType", "detail": "Assert value is not of type", "params": "(value, typeName, message?)", "returns": {"type": "null"}, "documentation": "Asserts value is not of the given type.", "signature": {"label": "@.Assert.isNotType(value: any, typeName: string, message?: string)", "parameters": [{"label": "value", "documentation": "Value to check"}, {"label": "typeName", "documentation": "Type: number, date, string, node, array, boolean"}, {"label": "message", "documentation": "Optional custom failure message"}], "documentation": "Asserts value is not of type"}},
    {"namespace": "Load", "name": "From", "detail": "Load file as JSON (test context)", "params": "(fileName)", "returns": {"type": "Object"}, "documentation": "Loads .json, .yaml, .yml, or .csv from file path relative to current ISL file. Available in test context only.", "signature": {"label": "@.Load.From(fileName: string)", "parameters": [{"label": "fileName", "documentation": "Path relative to current file (e.g. fixtures/data.json)"}], "documentation": "Loads file and converts to JSON"}},
    {"namespace": "Mock", "name": "Func", "detail": "Mock a function", "params": "(functionName, returnValue?, param0?, param1?, ...)", "returns": {"type": "Number"}, "documentation": "Registers a mock for a function (e.g. Module.funcName). Returns instance ID. Use Mock.GetFuncCaptures to get captured params.", "signature": {"label": "@.Mock.Func(functionName: string, returnValue?: any, ...params)", "parameters": [{"label": "functionName", "documentation": "Full name e.g. This.myFunc or Module.funcName"}, {"label": "returnValue", "documentation": "Optional return value when mock is called"}, {"label": "params", "documentation": "Optional param matchers by index"}], "documentation": "Mocks a function for testing"}},
    {"namespace": "Mock", "name": "Annotation", "detail": "Mock an annotation", "params": "(annotationName, returnValue?, param0?, ...)", "returns": {"type": "Number"}, "documentation": "Registers a mock for an annotation. Returns instance ID. Use Mock.GetAnnotationCaptures to get captured params.", "signature": {"label": "@.Mock.Annotation(annotationName: string, returnValue?: any, ...params)", "parameters": [{"label": "annotationName", "documentation": "Annotation name (e.g. test, setup)"}, {"label": "returnValue", "documentation": "Optional return value"}, {"label": "params", "documentation": "Optional param matchers"}], "documentation": "Mocks an annotation for testing"}},
    {"namespace": "Mock", "name": "StatementFunc", "detail": "Mock a statement function", "params": "(functionName, returnValue?, param0?, ...)", "returns": {"type": "Number"}, "documentation": "Registers a mock for a statement function (block syntax). Returns instance ID.", "signature": {"label": "@.Mock.StatementFunc(functionName: string, returnValue?: any, ...params)", "parameters": [{"label": "functionName", "documentation": "Full name e.g. Module.statementFunc"}, {"label": "returnValue", "documentation": "Optional"}, {"label": "params", "documentation": "Optional param matchers"}], "documentation": "Mocks a statement function"}},
    {"namespace": "Mock", "name": "GetFuncCaptures", "detail": "Get captured params from function mock", "params": "(functionName, instanceId?)", "returns": {"type": "Array"}, "documentation": "Returns array of captured parameter maps from Mock.Func calls.", "signature": {"label": "@.Mock.GetFuncCaptures(functionName: string, instanceId?: number)", "parameters": [{"label": "functionName", "documentation": "Same name used in Mock.Func"}, {"label": "instanceId", "documentation": "Optional instance ID from Mock.Func"}], "documentation": "Gets captured params from function mock"}},
    {"namespace": "Mock", "name": "GetAnnotationCaptures", "detail": "Get captured params from annotation mock", "params": "(annotationName, instanceId?)", "returns": {"type": "Array"}, "documentation": "Returns array of captured parameter maps from Mock.Annotation calls.", "signature": {"label": "@.Mock.GetAnnotationCaptures(annotationName: string, instanceId?: number)", "parameters": [{"label": "annotationName", "documentation": "Same name used in Mock.Annotation"}, {"label": "instanceId", "documentation": "Optional instance ID from Mock.Annotation"}], "documentation": "Gets captured params from annotation mock"}},
    {"namespace": "Mock", "name": "GetStatementFuncCaptures", "detail": "Get captured params from statement func mock", "params": "(functionName, instanceId?)", "returns": {"type": "Array"}, "documentation": "Returns array of captured parameter maps from Mock.StatementFunc calls.", "signature": {"label": "@.Mock.GetStatementFuncCaptures(functionName: string, instanceId?: number)", "parameters": [{"label": "functionName", "documentation": "Same name used in Mock.StatementFunc"}, {"label": "instanceId", "documentation": "Optional instance ID"}], "documentation": "Gets captured params from statement func mock"}}
  ],
  "services": [
    {"name": "This", "detail": "Call functions in current script", "documentation": "Provides access to functions defined in the current ISL file.\n\nType `@.This.` to see available functions."},
    {"name": "Date", "detail": "Date/time operations", "documentation": "Date and time operations (UTC).\n\n**Methods:**\n- `Now()` - Current date/time\n- `parse(string, format)` - Parse date\n- `fromEpochSeconds(seconds)`\n- `fromEpochMillis(millis)`"},
    {"name": "Math", "detail": "Math operations", "documentation": "Mathematical operations on arrays and numbers.\n\nUse with arrays: `$total: $prices | Math.sum(0)`\n\nRandom numbers: `Math.RandInt(1, 100)`"},
    {"name": "String", "detail": "String operations", "documentation": "String manipulation functions."},
    {"name": "Array", "detail": "Array operations", "documentation": "Array manipulation functions.\n\n`Array.range(0, 10, 1)` creates array [0..9]"},
    {"name": "Json", "detail": "JSON operations", "documentation": "JSON parsing and serialization.\n\n```isl\n$obj: @.Json.parse($jsonString);\n```"},
    {"name": "Xml", "detail": "XML operations", "documentation": "XML parsing and generation.\n\nAttributes use @ prefix, text uses #text"},
    {"name": "Csv", "detail": "CSV operations", "documentation": "CSV parsing via modifiers.\n\n```isl\n$data: $csvText | csv.parsemultiline;\n$rowIndex: $csvText | csv.findrow({seek: [\"id\"], maxRows: 100});\n```"},
    {"name": "Crypto", "detail": "Cryptography functions", "documentation": "Hash and crypto via modifiers: Crypto.sha256, Crypto.sha1, Crypto.md5, Crypto.hmacsha256, Crypto.decrypt, Crypto.verify, etc."},
    {"name": "Run", "detail": "Runtime helpers", "documentation": "**Methods:**\n- `Run.Sleep(ms)` - Pause execution"},
    {"name": "UUID", "detail": "UUID generation", "documentation": "**Methods:**\n- `UUID.New()` - New UUID string"},
    {"name": "Zip", "detail": "Zip archive", "documentation": "**Methods:**\n- `Zip.Start()` - Create zip; then `| zip.add(\"name\", content) | zip.close`\n- `$bytes | unzip` - Unzip to array of {name, content}"},
    {"name": "Assert", "detail": "Test assertions (isl-test)", "documentation": "Assertion functions for ISL tests. Use with `isl-test`.\n\n**Equality:** equal, notEqual, isNull, notNull\n**Comparison:** lessThan, lessThanOrEqual, greaterThan, greaterThanOrEqual\n**String:** matches, notMatches, contains, notContains, startsWith, notStartsWith, endsWith, notEndsWith\n**Collection:** in, notIn\n**Type:** isType, isNotType"},
    {"name": "Load", "detail": "Load resources from files (test context)", "documentation": "Load files relative to current ISL file. Available in test context only.\n\n**Methods:**\n- `Load.From(fileName)` - Load .json, .yaml, .yml, or .csv; converts to JSON"},
    {"name": "Mock", "detail": "Mock functions and annotations (test context)", "documentation": "Mocking for ISL tests. Available in test context only.\n\n**Methods:**\n- `Mock.Func(functionName, returnValue?, ...params)` - Mock a function\n- `Mock.Annotation(annotationName, returnValue?, ...params)` - Mock an annotation\n- `Mock.StatementFunc(functionName, returnValue?, ...params)` - Mock a statement function\n- `Mock.GetFuncCaptures(functionName, instanceId?)` - Get captured params\n- `Mock.GetAnnotationCaptures(annotationName, instanceId?)` - Get annotation captures\n- `Mock.GetStatementFuncCaptures(functionName, instanceId?)` - Get statement func captures"}
  ],
  "annotations": [
    {"name": "test", "detail": "Mark function as test", "insertText": "test", "documentation": "Marks a function as a test. Discovered by Test Explorer.\n\n**Forms:**\n- `@test` - Use function name as test name\n- `@test(\"Custom name\")` - Custom test name\n- `@test(name, group)` - Name and group\n- `@test({ name: \"x\", group: \"y\" })` - Object form"},
    {"name": "setup", "detail": "Setup runs before each test", "insertText": "setup", "documentation": "Marks a function as setup. Runs before each test in the file.\n\nUse with `fun setup()` to initialize shared state."}
  ]
}
