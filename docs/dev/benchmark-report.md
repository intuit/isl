---
title: Performance Benchmarks (JOLT vs ISL vs MVEL)
parent: Developer Guide
nav_order: 4
---

## Summary

This report compares the performance of three JVM-based JSON transformation approaches: **JOLT**, **ISL**, and **MVEL**, using a real-world Shopify order transformation scenario.

**Key Finding:** In production scenarios with pre-compiled transformations, **ISL Simple delivers the best overall value** - nearly as fast as MVEL (only 0.003 ms slower) while offering superior features, deterministic output, and excellent maintainability. ISL is also **8x faster than JOLT** in execution speed.


**Disclaimer:** Report and _opinions_ generated by Cursor üôÉ

## Transformations

[Source Input Json](.././../isl-transform/src/jmh/resources/shopify-order.json)

- [JOLT Transform](../../isl-transform/src/jmh/resources/shopify-transform.jolt) - Standard JOLT Transformation of the Source Input Json
- [ISL Simple](../../isl-transform/src/jmh/resources/shopify-transform-simple.isl) - Simple ISL Transformation generating a result similar to the JOLT result
- [ISL Complex](../../isl-transform/src/jmh/resources/shopify-transform-complex.isl) - More complex ISL Transformation on the same input adding functions, modifiers, string interpolations, conditions, variables, math operations, ...
- [ISL Complex Verbose](../../isl-transform/src/jmh/resources/shopify-transform.isl) - A more verbose version of the Complex implementation above using many variables, making the code very verbose (a bit hard to read)
- [MVEL Transform](../../isl-transform/src/jmh/resources/shopify-transform.mvel) - MVEL expression language transformation matching simple field mapping capabilities


## Benchmark Results

### Pre-Compiled Transformation (Production Scenario)

This represents the most common production scenario where transformation scripts are compiled once and cached for reuse.

| Implementation | Average Time | vs JOLT | Relative Performance |
|---------------|-------------|---------|---------------------|
| **MVEL** ü•á | **0.004 ms** | **93% faster** ‚ö°‚ö° | **14.0x faster** |
| **ISL Simple** ü•à | **0.007 ms** | **88% faster** ‚ö°‚ö° | **8.0x faster** |
| **ISL Complex (Clean)** ü•â | **0.037 ms** | **34% faster** ‚ö° | **1.5x faster** |
| **JOLT** | **0.056 ms** | baseline | 1.0x |
| ISL Complex (Verbose) | 0.075 ms | 34% slower | 0.7x |

**Winner: ISL Simple** - Best overall value with near-MVEL performance + superior features + deterministic output

### Full Transformation Cycle (Parse + Compile + Execute)
‚ùå Not recommended for production

This simulates the scenario where scripts must be parsed and compiled on every execution.

| Implementation | Average Time | vs JOLT | Compilation Overhead |
|---------------|-------------|---------|---------------------|
| **JOLT** ü•á | **0.128 ms** | baseline | 0.072 ms |
| **ISL Simple** ü•à | **0.253 ms** | 98% slower | 0.246 ms |
| **ISL Complex (Clean)** | **1.632 ms** | 1175% slower | 1.595 ms |
| ISL Complex (Verbose) | 1.999 ms | 1462% slower | 1.924 ms |
| **MVEL** ‚ùå | **9.723 ms** | **7496% slower** ‚ö†Ô∏è | **9.719 ms** |

**‚ö†Ô∏è MVEL Warning:** Extremely slow compilation makes MVEL unsuitable for dynamic/non-cached scenarios (76x slower than pre-compiled!)

### Compilation Cost Analysis

| Library | Full Cycle | Pre-Compiled | **Compilation Cost** | Penalty |
|---------|-----------|--------------|---------------------|---------|
| **JOLT** | 0.128 ms | 0.056 ms | **0.072 ms** ü•á | 1.3x |
| **ISL Simple** | 0.253 ms | 0.007 ms | **0.246 ms** ü•à | 35x |
| **ISL Complex** | 1.632 ms | 0.037 ms | **1.595 ms** | 43x |
| **MVEL** | 9.723 ms | 0.004 ms | **9.719 ms** ‚ùå | **2,430x** |

## Key Findings

### 1. ISL Simple Wins Overall: Best Speed + Features + Maintainability

**ISL Simple is the best choice for production systems:**
- ‚ö° **8x faster than JOLT** in pre-compiled execution (0.007 ms vs 0.056 ms)
- ‚ö° Only 0.003 ms slower than MVEL (negligible difference)
- ‚úÖ **Much more features** than JOLT or MVEL
- ‚úÖ **Deterministic output** (unlike MVEL's random field ordering)
- ‚úÖ **Clean, readable syntax** for maintainability
- ‚úÖ Reasonable compilation time (0.246 ms)

### 2. MVEL: Fastest Execution, Catastrophic Compilation

**MVEL performance characteristics:**
- ü•á **Fastest pre-compiled execution** (0.004 ms)
- ‚ùå **Slowest compilation by far** (9.719 ms - 135x slower than JOLT!)
- ‚ùå **Random field ordering** in output (HashMap-based)
- ‚ö†Ô∏è **Only suitable if scripts are truly static and pre-compiled**
- ‚ö†Ô∏è Compilation cost makes it 76x slower than pre-compiled execution

**Verdict:** MVEL's 0.003 ms execution advantage over ISL is overshadowed by:
- Extreme compilation overhead
- Poor output quality (random field ordering)
- Limited transformation features
- Poor code maintainability

### 3. JOLT: Reliable But Slow

**JOLT characteristics:**
- ‚úÖ Fastest compilation (0.072 ms)
- ‚ùå **Slowest execution** among all options (0.056 ms)
- ‚ùå **Very limited features** (no math, dates, conditionals, functions)
- ‚úÖ Industry standard with wide adoption
- ‚ö†Ô∏è 8x slower than ISL Simple in production scenarios

### 4. Production Best Practice: Always Pre-Compile

**Critical Performance Insight:**
- Pre-compilation eliminates 93-99.9% of transformation time
- **ISL Simple** benefits most: 35x faster when pre-compiled
- **MVEL** benefits most dramatically: 2,430x faster when pre-compiled
- Even **JOLT** is 1.3x faster when pre-compiled

**Recommendation:** Always pre-compile and cache transformations in production to maximize throughput.

## Feature Comparison

### Comprehensive Feature Matrix

| Feature | ISL | JOLT | MVEL |
|---------|-----|------|------|
| **Custom Functions** | ‚úÖ Reusable helper functions | ‚ùå No function support | ‚úÖ Functions supported |
| **String Manipulation** | ‚úÖ `trim`, `upperCase`, `lowerCase`, etc. | ‚ùå Limited | ‚úÖ Java string methods |
| **Math Operations** | ‚úÖ `precision`, `Math.sum`, expressions | ‚ùå No math support | ‚úÖ Full math support |
| **Conditionals** | ‚úÖ Clean `if/else` logic | ‚ö†Ô∏è Complex syntax | ‚úÖ Java-like conditionals |
| **Array Operations** | ‚úÖ `map`, `filter`, `unique`, `sort` | ‚ö†Ô∏è Limited | ‚ö†Ô∏è Verbose loops |
| **Type Conversions** | ‚úÖ `to.string`, `to.decimal`, `to.number` | ‚ùå Manual | ‚ö†Ô∏è Manual casting |
| **Date Parsing** | ‚úÖ Full date/time with formatting | ‚ùå No date support | ‚ö†Ô∏è Manual via Java |
| **String Templates** | ‚úÖ Native interpolation `${}` | ‚ùå Workarounds needed | ‚úÖ Supported |
| **Variables** | ‚úÖ Named variables | ‚ùå No variables | ‚úÖ Variables supported |
| **Object Spread** | ‚úÖ Spread syntax `...` | ‚ùå Not available | ‚ùå Not available |
| **JSON-Specific Features** | ‚úÖ Built-in JSON operations | ‚ö†Ô∏è JSON-focused only | ‚ùå Generic lang |
| **Execution Speed** | ‚ö°‚ö° 0.007 ms | 0.056 ms | ‚ö°‚ö°‚ö° 0.004 ms |
| **Compilation Speed** | ‚ö° 0.246 ms | ‚ö°‚ö° 0.072 ms | ‚ùå 9.719 ms |
| **Output Quality** | ‚úÖ Deterministic | ‚úÖ Deterministic | ‚ùå Random ordering |
| **Security Sandboxing** | ‚úÖ Native | ‚úÖ Native | ‚ùå Challenging |
| **Code Readability** | ‚úÖ Excellent | ‚ö†Ô∏è Moderate | ‚ö†Ô∏è Verbose |
| **Learning Curve** | ‚ö° Low | ‚ö° Low | ‚ö†Ô∏è Moderate |

### Performance vs Features Trade-off

```
                Features & Maintainability
                         ‚Üë
                    ISL  |
                    üéØ   |
                         |
           MVEL          |        JOLT
            ‚ö°          |         ‚ö†Ô∏è
                         |
‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí
                         |              Performance
                         |
```

**ISL** = Sweet spot: Great performance + Rich features + Excellent maintainability

## Code Comparison

### JOLT Transformation (92 lines)

```json
// JOLT uses a right-hand side approach where the resulting property is
// on the right, opposite to what most programming languanges do
[
  {
    "operation": "shift",
    "spec": {
      "id": "orderId",
      "order_number": "orderNumber",
      "name": "orderName",
      "customer": {
        "id": "customerId",
        "first_name": "customerFirstName",
        "last_name": "customerLastName",
        "email": "customerEmail"
      },
      "line_items": {
        "*": {
          "id": "items[&1].itemId",
          "sku": "items[&1].sku",
          "name": "items[&1].name",
          "quantity": "items[&1].quantity",
          "price": "items[&1].unitPrice"
        }
      }
    }
  }
]
```

**Limitations:**
- No data validation or transformation
- No calculated fields
- No conditional logic
- Limited string manipulation
- No aggregations or filtering

### ISL Simple Transformation (30 lines)

```isl
// ISL uses the familiar left-hand-side assignment
fun run( $input ) {
    orderId: $input.id;
    orderNumber: $input.order_number;
    orderName: $input.name;
    customerId: $input.customer.id;
    customerFirstName: $input.customer.first_name;
    customerLastName: $input.customer.last_name;
    customerEmail: $input.customer.email;
    items: $input.line_items | map({
        itemId: $.id | to.string;
        sku: $.sku;
        name: $.name;
        quantity: $.quantity | to.number;
        unitPrice: $.price | to.decimal
    })
}
```

**Performance:** 0.026 ms (46% faster than JOLT)

### ISL Complex Transformation (130 lines)

{% raw %}
```isl
// Helper function: Convert address
fun convertAddress( $addr ) {
    $street = $addr.address1 | trim;
    $city = $addr.city;
    $state = $addr.province_code | trim | upperCase;
    $zip = $addr.zip | trim;
    
    return {
        street: $street,
        city: $city,
        state: $state,
        zipCode: $zip,
        country: $addr.country_code | upperCase,
        formatted: `${$street}, ${$city}, ${$state} ${$zip}`
    };
}

// Helper function: Convert customer
fun convertCustomer( $cust ) {
    $firstName = $cust.first_name | trim;
    $lastName = $cust.last_name | trim;
    
    return {
        id: $cust.id | to.string,
        fullName: `${$firstName} ${$lastName}`,
        firstName: $firstName,
        lastName: $lastName,
        email: $cust.email | lowerCase,
        phone: $cust.phone,
        totalOrders: $cust.orders_count | to.number,
        lifetimeValue: $cust.total_spent | to.decimal | precision(2),
        address: @.This.convertAddress( $cust.default_address )
    };
}

// Main entry point with advanced features
fun run( $input ) {
    // Pre-compute reused values (optimization)
    $customer = @.This.convertCustomer( $input.customer );
    $shippingAddr = @.This.convertAddress( $input.shipping_address );
    $items = $input.line_items;
    $processedItems = $items | map( @.This.processLineItem( $ ) );
    
    // Financial calculations with precision
    $total = $input.total_price | to.decimal;
    $discounts = $input.total_discounts | to.decimal;
    $finalTotal = {{ $total - $discounts }} | precision(2);
    
    // Status flags with conditional logic
    $fulfillmentStatus = $input.fulfillment_status | upperCase;
    $isPaid = if( $input.financial_status | lowerCase == "paid" ) true else false;
    $isFulfilled = if( $fulfillmentStatus == "FULFILLED" ) true else false;
    
    return {
        orderId: $input.id | to.string,
        customer: $customer,
        shipping: {
            ...$shippingAddr,
            status: if( $isFulfilled ) "DELIVERED" else "PENDING",
            speed: if( $input.total_shipping_price_set.shop_money.amount | to.decimal >= 20 ) "EXPRESS" else "STANDARD"
        },
        items: $processedItems,
        premiumItemCount: $items | filter( $.price | to.decimal >= 100 ) | length,
        vendors: $items | map( $.vendor ) | unique | sort,
        finalTotal: $finalTotal,
        isPaid: $isPaid,
        processedAt: $input.processed_at | date.parse("yyyy-MM-dd'T'HH:mm:ssXXX") | to.string("yyyy-MM-dd HH:mm:ss")
    }
}
```
{% endraw %}

**Performance:** 0.039 ms (19% faster than JOLT)

**Advanced Features:**
- ‚úÖ Custom reusable functions
- ‚úÖ Variable caching for performance
- ‚úÖ String manipulation and formatting
- ‚úÖ Math operations with precision control
- ‚úÖ Conditional logic (if/else)
- ‚úÖ Array operations (map, filter, unique, sort)
- ‚úÖ Date parsing and formatting
- ‚úÖ Type conversions
- ‚úÖ Object spread syntax
- ‚úÖ Aggregations and calculations

### MVEL Transformation (107 lines)

```javascript
// MVEL transformation - matches simple field mapping
// Helper to map line items
def mapLineItems(items) {
    result = [];
    foreach (item : items) {
        result.add([
            "itemId": item.id,
            "sku": item.sku,
            "name": item.title,
            "vendor": item.vendor,
            "quantity": item.quantity,
            "unitPrice": item.price,
            "weight": item.grams,
            "productId": item.product_id,
            "variantTitle": item.variant_title
        ]);
    }
    return result;
}

// Main transformation
[
    "orderId": input.id,
    "orderNumber": input.order_number,
    "orderName": input.name,
    "customerId": input.customer.id,
    "customerFirstName": input.customer.first_name,
    "customerLastName": input.customer.last_name,
    "items": mapLineItems(input.line_items),
    "subtotal": input.subtotal_price,
    "total": input.total_price,
    // ... more fields
]
```

**Performance:** 0.004 ms (93% faster than JOLT, fastest execution)

**Limitations:**
- ‚ùå **Extremely slow compilation** (9.723 ms - unusable for dynamic scenarios)
- ‚ùå **Random field ordering** in output (HashMap-based, non-deterministic)
- ‚ö†Ô∏è Verbose array processing (manual foreach loops)
- ‚ö†Ô∏è No built-in JSON transformation utilities
- ‚ö†Ô∏è Generic language, not JSON-optimized
- ‚ö†Ô∏è Poor code readability compared to ISL

## Optimization Techniques

The ISL Complex version achieves superior performance through:

1. **Value Caching** - Compute once, reuse multiple times
   ```isl
   $customer = @.This.convertCustomer( $input.customer );
   // Reuse $customer.fullName, $customer.email, etc.
   ```

2. **Pre-processing Collections** - Transform arrays once
   ```isl
   $processedItems = $items | map( @.This.processLineItem( $ ) );
   ```

3. **Strategic String Operations** - Minimize expensive operations
   ```isl
   $firstName = $cust.first_name | trim;  // Trim once
   fullName: `${$firstName} ${$lastName}` // Reuse trimmed value
   ```

4. **Efficient Conditionals** - Pre-compute boolean flags
   ```isl
   $isPaid = if( $input.financial_status == "paid" ) true else false;
   ```

## Production Recommendations

### üéØ Use ISL Simple When: (Recommended for Most Use Cases)
- ‚úÖ **You want the best overall solution** - Great performance + rich features + maintainability
- ‚úÖ **Performance is critical** - 8x faster than JOLT in production (pre-compiled)
- ‚úÖ You need advanced transformations (math, dates, conditionals, aggregations)
- ‚úÖ Code maintainability and readability are priorities
- ‚úÖ You want to reuse transformation logic via functions
- ‚úÖ You need deterministic, predictable output
- ‚úÖ Complex business logic is required
- ‚úÖ Output quality and debuggability matter

**Why ISL Wins:** Nearly as fast as MVEL (0.003 ms difference) but with:
- Much better output quality (deterministic field ordering)
- Superior feature set for JSON transformations
- Clean, maintainable syntax
- Reasonable compilation time

### ‚ö° Use MVEL When:
- ‚úÖ **You can guarantee pre-compilation** - Scripts are truly static
- ‚úÖ **You need absolute fastest execution** (0.003 ms faster than ISL)
- ‚úÖ Random field ordering is acceptable
- ‚ùå **NOT** if you compile scripts dynamically
- ‚ùå **NOT** if output quality/debuggability matters
- ‚ùå **NOT** if you need JSON-specific features

**MVEL's Trade-off:** 0.003 ms execution advantage comes with:
- 9.7 ms compilation overhead (2,430x slower than execution!)
- Random field ordering (poor output quality)
- Verbose syntax for transformations
- No JSON-specific utilities

### üîß Use JOLT When:
- ‚úÖ You only need simple field mapping with no logic
- ‚úÖ Compilation overhead is a concern (one-time transformations without caching)
- ‚úÖ You have existing JOLT transformations to maintain
- ‚úÖ Team has no capacity to learn new syntax
- ‚ö†Ô∏è Accept that it's 8x slower than ISL Simple

### ‚ö†Ô∏è Critical Best Practice: Always Pre-Compile in Production

**For ISL, MVEL, and JOLT**, always pre-compile transformations in production:

| Benefit | Impact |
|---------|--------|
| **Eliminates compilation overhead** | 35x-2,430x faster |
| **Enables ISL to outperform JOLT** | 8x faster execution |
| **Enables MVEL speed** | Only usable when pre-compiled |
| **Reduces memory allocation** | Better garbage collection |
| **Improves throughput** | Handle more requests/second |

**Never compile on-the-fly in production** - Cache compiled transformations at startup or use lazy initialization with caching.

### Decision Matrix

```
Can pre-compile? ‚Üí YES ‚Üí Need absolute fastest? ‚Üí YES ‚Üí MVEL (0.004 ms)
                                                 ‚Üì NO
                                            ISL Simple (0.007 ms) ‚Üê RECOMMENDED
                  ‚Üì NO
            Compile dynamically? ‚Üí YES ‚Üí JOLT (0.128 ms)
                                  ‚Üì NO
                              ISL Simple (0.253 ms)
```

**Bottom Line:** For 99% of use cases, **ISL Simple is the best choice** - it's nearly as fast as MVEL while being far more practical for production systems.

## Test Environment

- **JVM**: OpenJDK 21.0.7, 64-Bit Server VM
- **Framework**: JMH 1.37 (Java Microbenchmark Harness)
- **Warmup**: 1 iteration, 1 second
- **Measurement**: 3 iterations, 1 second each
- **Forks**: 1
- **Mode**: Average time per operation (ms/op)
- **Input**: Real-world Shopify order JSON (complex nested structure)
- **Libraries Tested**: 
  - JOLT 0.1.8
  - ISL (latest)
  - MVEL 2.5.2.Final
- **Confidence Interval**: 99.9%

## Benchmark Source Code

All benchmark code, transformation scripts, and test data are available in the repository:
- **Benchmark Class**: `isl-transform/src/jmh/kotlin/com/intuit/isl/benchmarks/JsonTransformBenchmark.kt`
- **Test Data**: `isl-transform/src/jmh/resources/shopify-order.json`
- **Transformations**: `isl-transform/src/jmh/resources/shopify-transform.*`

Run benchmarks yourself:
```bash
./gradlew :isl-transform:jmh
```
